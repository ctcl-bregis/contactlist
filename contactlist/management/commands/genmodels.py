# ContactList - CTCL 2023
# Date: June 9, 2023 - June 15, 2023
# Purpose: Management command for generating database models, form data and other files

# Valid data types
# - date: datetime.date object, editable via Django DateField form class
# - select: Value chosen by a dropdown menu
# - string: Text input with a text length limit
# - text: Text input without a text length limit
# - time: datetime.time object set by the app, not user editable

from django.core.management.base import BaseCommand, CommandError
import os, csv, shutil
from datetime import datetime, timezone

def configchoices(dbconfig):
    table = ""
    for i in dbconfig:
        if i["datatype"] == "select":
            try:
                choicelist = f"choices_{i['col']} = [\n"
                with open(i["ddfile"]) as f:
                    ddconfig = list(csv.DictReader(f))
                # Add blank choice
                choicelist += f"    (\"\", \"\"),\n"
                for i in ddconfig:
                    choicelist += f"    (\"{i['choice']}\", \"{i['disp']}\"),\n"
                choicelist += "]\n\n"
                
                table += choicelist
            
            except FileNotFoundError:
                print(f"WARNING: {i['ddfile']} does not exist, skipping")
            
    d = datetime.now(timezone.utc)
    choicespy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Dropdown choices
# THIS FILE IS AUTOMATICALLY GENERATED

{table}

""".format(date = d.strftime("%B %e, %Y"), table = table)

    return choicespy

def configfields(dbconfig):
    table = ""
    for i in dbconfig:
        dt = i["datatype"]
        col = i["col"]
        
        if dt == "date":
            table += f"    {col} = forms.DateField(label = \"{i['name']}\", required = {i['required']} )\n"
        elif dt == "select":
            table += f"    {col} = forms.ChoiceField(label = \"{i['name']}\", choices = choices.choices_{i['col']}, required = {i['required']})\n"
        elif dt == "string":
            table += f"    {col} = forms.CharField(label = \"{i['name']}\", min_length = {i['min']}, max_length = {i['max']}, required = {i['required']})\n"
        elif dt == "text":
            table += f"    {col} = forms.CharField(label = \"{i['name']}\", widget = forms.Textarea, required = {i['required']})\n"
        else:
            pass
            
    d = datetime.now(timezone.utc)
    fieldspy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Django form data
# THIS FILE IS AUTOMATICALLY GENERATED

from django import forms
from . import choices

class ContactForm(forms.Form):
{table}

""".format(date = d.strftime("%B %e, %Y"), table = table)

    return fieldspy

def configmodels(dbconfig):    
    table = ""
    for i in dbconfig:
        dt = i["datatype"]
        
        if dt == "select":
            table += f"    {i['col']} = models.CharField(max_length = 128, choices = choices.choices_{i['col']})\n" 
        elif dt == "string" or dt == "text":
            table += f"    {i['col']} = models.TextField(blank = True)\n"
        elif dt == "time":
            table += f"    {i['col']} = models.DateTimeField(null = True)\n"
        elif dt == "date":
            table += f"    {i['col']} = models.DateField(null = True)\n"
        else:
            print(f"WARNING: Unknown datatype \"{dt}\", skipping")
        
    colnames = [i["col"] for i in dbconfig]
    todict = "\"inid\": self.inid, "
    for i in dbconfig:
        todict += f"\"{i['col']}\": self.{i['col']}, "
    todict = "return {" + todict + "}"
    
    d = datetime.now(timezone.utc)
    modelspy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Database model metadata
# THIS FILE IS AUTOMATICALLY GENERATED

from django.utils import timezone
from django.db import models
from . import choices

class ContactItem(models.Model):
    inid = models.AutoField(primary_key = True)
{table}
    class Meta:
        verbose_name_plural = "Contact Entries"

    def todict(self):
        {todict}
        
    def __str__(self):
        return self.name

""".format(date = d.strftime("%B %e, %Y"), table = table, todict = todict)
    
    return modelspy
    
# Configuration data for what is shown in the HTML table
def configtable(tconfig, dbconfig):
    
    tdbconfig = [i if i
    
    tmplst = []
    for x, y in zip(tconfig, dbconfig):
        if i["preview"] == "True":
            tmplst.append({x["col"]: {"name": y["name"], y"})

    d = datetime.now(timezone.utc)
    tablepy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: HTML table config
# THIS FILE IS AUTOMATICALLY GENERATED

htmltable = {table}

""".format(date = d.strftime("%B %e, %Y"), table = tmplst)

    return tablepy

class Command(BaseCommand):
    help = "Generates a model.py for the application using config files under config/database/"
    
    def handle(self, *args, **options):
        # Create a backup of the database since migrations may wipe the data
        if os.path.exists("db.sqlite3"):
            if os.path.exists("db_backup.sqlite3"):
                os.remove("db_backup.sqlite3")
                
            shutil.copyfile("db.sqlite3", "db_backup.sqlite3")
        
        # Current working directory should be the project root
        try:
            with open("config/database/entry.csv") as f:
                dbconfig = list(csv.DictReader(f))
        except FileNotFoundError:
            print("config/database/entry.csv does not exist")
            return
        
        try:
            with open("config/htmltable.csv") as f:
                tconfig = list(csv.DictReader(f))
        except FileNotFoundError:
            print("config/htmltable.csv does not exist") 
        
        with open("contactlist/choices.py", "w") as f:
            f.write(configchoices(dbconfig))
        
        with open("contactlist/fields.py", "w") as f:
            f.write(configfields(dbconfig))
        
        with open("contactlist/models.py", "w") as f:
            f.write(configmodels(dbconfig))
            
        with open("contactlist/tableconfig.py", "w") as f:
            f.write(configtable(tconfig, dbconfig))
