# ContactList - CTCL 2023
# File: build.py
# Purpose: Management command for generating database models, form data and other files
# Created: June 9, 2023
# Modified: August 21, 2023

import json
import os
import platform
import shutil
import sys
from datetime import datetime, timezone
from csscompressor import compress
from django.core.management.base import BaseCommand, CommandError
from scss import Compiler

# Function that keeps error messages consistent
def perror(func, message):
    print(f"build.py {func} ERROR: {message}")
    sys.exit(1)

# Same function as perror but it does not exit
def pwarn(func, message):
    print(f"build.py {func} WARNING: {message}")

# Collect themes from the "themes" directory
def themeloader(themeconfigdir):
    themedir = [f for f in os.listdir(themeconfigdir) if os.path.isdir(os.path.join(themeconfigdir, f))]
    themelist = []
    for i in themedir:
        try:
            with open(f"{themeconfigdir}{i}/index.json") as f:
                themedata = dict(json.load(f))["theme"]
                themelist.append(themedata)
        except FileNotFoundError:
            perror("themeloader", f"Theme does not have a index.json, the theme \"{i}\" would not be available")
        except (json.JSONDecodeError, json.decoder.JSONDecodeError) as e:
            perror("themeloader", f"Exception \"{e}\" raised by JSON library, the theme \"{i}\" would not be available")

    # Exit the script if there are no themes
    if len(themelist) < 1:
        perror("themeloader", f"No themes were found in the directory {themeconfigdir}")

    return themelist

# Load configuration for each defined table
def tableloader(configjson):
    tablegroups = {}
    for metatable in configjson["tables"]:
        tables = {}
        for cfgtable in metatable["tables"]:
            # Is the "important" key set to "True"? If the config has this table with the "important" set to "True", the app will not run without it.
            if cfgtable["important"] == "True":
                important = True

            table = {}
            # What is appended to for each class name
            prefix = cfgtable["classprefix"]
            with open(cfgtable["cfg"]) as f:
                tableconfig = json.loads(f.read())["table"]

            # Assign the tableconfig dictionary to table as many of the same values are used
            table = tableconfig

            table["choicesclass"] = prefix + "Choices"
            table["modelclass"] = prefix + "Item"
            table["fieldsclass"] = prefix + "Field"

            # Keys critical for table configuration
            # "dropdown" is optional
            keys = ["headers", "tablecats", "table"]
            for key in keys:
                if not key in table:
                    if important:
                        perror("tableloader", f"Key {key} missing from the configuration table.")
                    else:
                        pwarn("tableloader", f"Key {key} missing from the configuration table. The table config \"{prefix}\" would be unavailable.")
                        break
            else:
                # This should be the last assignment in the for loop
                tables[prefix] = table

        tablegroups[metatable["metaprefix"]] = tables

    return tablegroups

# Takes in a list of dictionaries containing theme data and returns the JSON source
def configthemes(configjson, themelist):
    basescsspath = configjson["misc"]["basescss"]

    if os.path.exists(basescsspath) and os.path.isfile(basescsspath):
        with open(configjson["misc"]["basescss"]) as f:
            basescss = f.read()
            try:
                basecss = Compiler().compile_string(basescss)
            except Exception as err:
                perror("configthemes", "Sass compilation error when processing base.scss: {err}")
    elif os.path.exists(basescsspath) and not os.path.isfile(basescsspath):
        perror("configthemes", "\"{basescsspath}\" is not a file")
    else:
        perror("configthemes", "\"{basescssfile}\" does not exist")

    for theme in themelist:
        themedict = {}
        try:
            theme["css"] = Compiler().compile_string(theme["scss"])
        except Exception as err:
            pwarn("configthemes", f"Sass compilation error while processing theme \"{theme['int_name']}\": {err}")

        themedict[theme["int_name"]] = theme

    source = json.dumps(themedict)

    return source


# Takes in a list of table configurations and returns the Python source
def configchoices(configjson, tables, themelist):
    themelist = json.loads(themelist)

    print(tables)

    tmp = {}
    for metatable in tables:
        tmp.update(tables[metatable])
    tables = tmp

    d = datetime.now(timezone.utc)
    date = d.strftime("%B %e, %Y")
    source = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Dropdown choices
# THIS FILE IS AUTOMATICALLY GENERATED
""".format(date = date)

    themechoices = {}
    for k, v in themelist.items():
        themechoices[k] = v["disp_name"]

    for table in tables:
        source += """
class {classname}:
    choicedict = {choicedict}

    def totuplelist(ddlist):
        return list(self.choicedict[ddlist].items())
""".format(choicedict = tables[table]["dropdown"], classname = tables[table]["choicesclass"])

    # Add choice class for themes
    source += """
class ThemeChoices:
    choicedict = {themechoices}

    def totuplelist(ddlist):
        return list(self.choicedict[ddlist].items())
""".format(themechoices = themechoices)
    return source

# Takes in a list of table configurations and returns the source for models.py
def configmodels(configjson, tables):
    d = datetime.now(timezone.utc)
    date = d.strftime("%B %e, %Y")
    # File header and MetaTable
    source = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Database models
# THIS FILE IS AUTOMATICALLY GENERATED

from .choices import Choices
from django.utils import timezone
from django.db import models
from markdownx.models import MarkdownxField

class MetaTable(models.Model):
    inid = models.AutoField(primary_key = True)

""".format(date = date)

    for tablecfg in tables:
        tablecfg = tables[tablecfg]
        table = ""
        dbconfig = []
        cfgdata = {}
        for tablecat in tablecfg["table"].keys():
            dbconfig = tablecfg["table"][tablecat]
            for column in dbconfig:
                dt = column["datatype"]

                cfgdata[column["col"]] = column

                if dt in "select":
                    table += f"    {column['col']} = models.CharField(blank = True, max_length = 128, choices = Choices.totuplelist(\"{column['ddfile']}\"))\n    {column['col']}.group = \"{tablecat}\"\n"
                elif dt == "string":
                    table += f"    {column['col']} = models.CharField(blank = True, max_length = {column['max']})\n    {column['col']}.group = \"{tablecat}\"\n"
                elif dt == "text":
                    table += f"    {column['col']} = models.TextField(blank = True, null = True)\n    {column['col']}.group = \"{tablecat}\"\n"
                elif dt == "mdtext":
                    table += f"    {column['col']} = models.MarkdownxField(blank = True, null = True)\n    {column['col']}.group = \"{tablecat}\"\n"
                elif dt == "date":
                    table += f"    {column['col']} = models.DateField(null = True)\n    {column['col']}.group = \"{tablecat}\"\n"
                else:
                    pwarn("configmodels", f"Unknown datatype \"{dt}\", skipping")

        colnames = []
        for x in tablecfg["table"].keys():
            for y in tablecfg["table"][x]:
                colnames.append(y["col"])

        colnames = ["inid"] + colnames + ["tmod", "tcrd"]

        # todict() function for returning the dictionary representation of a given row
        todict = ""
        for i in colnames:
            todict += f"\"{i}\": self.{i}, "
        todict = "{" + todict + "}"

        source += """
class {classname}(models.Model):
    # inid, tcrd, tmod are not defined by the configuration file
    inid = models.ForeignKey({metatable})
    tcrd = models.DateTimeField(null = True)
    tmod = models.DateTimeField(null = True)

{table}
    class Meta:
        verbose_name_plural = "{classname}"

    def todict(self):
        return {todict}

    def cfgdata():
        return {cfgdata}

    def fieldnames():
        return {colnames}

    def __str__(self):
        return self.name
""".format(table = table, todict = todict, cfgdata = cfgdata, colnames = colnames, classname = tablecfg["modelclass"])


    return source


def configfields(configjson, tables):

    return source


class Command(BaseCommand):
    help = "Generates all of the needed files for the application."
    cwd = os.getcwd()

    def handle(self, *args, **options):
        # Create a backup of the database since migrations may wipe the data
        if os.path.exists("db.sqlite3"):
            if os.path.exists("db_backup.sqlite3"):
                os.remove("db_backup.sqlite3")
            shutil.copyfile("db.sqlite3", "db_backup.sqlite3")

        # Get global config
        try:
            with open("config/config.json") as f:
                configjson = json.loads(f.read())["config"]
        except FileNotFoundError:
            perror("config loader", "config/config.json does not exist. Current working directory is \"{cwd}\".")
        except (json.JSONDecodeError, json.decoder.JSONDecodeError) as e:
            perror("config loader", "Exception \"{e}\" raised by JSON library")

        tables = tableloader(configjson)

        themelist = themeloader("config/themes/")

        res_configthemes = configthemes(configjson, themelist)
        with open("themecfg.json", "w") as f:
            f.write(res_configthemes)

        res_configchoices = configchoices(configjson, tables, res_configthemes)
        with open("contactlist/choices.py", "w") as f:
            f.write(res_configchoices)

        res_configmodels = configmodels(configjson, tables)
        with open("contactlist/models.py", "w") as f:
            f.write(res_configmodels)

        #res_configfields = configfields(configjson, tables)
        #with open("contactlist/fields.py", "w") as f:
        #    f.write(res_configfields)