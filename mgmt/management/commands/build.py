# ContactList - CTCL 2023-2024
# File: build.py
# Purpose: Django management command for building needed files
# Created: June 9, 2023
# Modified: February 13, 2024

# Valid data types
# - date: datetime.date object, editable via Django DateField form class
# - select: Value chosen by a dropdown menu
# - string: Text input with a text length limit
# - text: Text input that is displayed using a textarea

from django.core.management.base import BaseCommand, CommandError
import os
import shutil
import json
from scss import Compiler
from datetime import datetime, timezone
from csscompressor import compress

# Take in the config file and return contents of choices.py
def configchoices(jsonconfig):
    choicedict = jsonconfig["dropdown"]
       
    d = datetime.now(timezone.utc)
    choicespy = """# ContactList - CTCL 2023-2024
# Generated: {date}
# Purpose: Dropdown choices
# THIS FILE IS AUTOMATICALLY GENERATED

class Choices:
    choicedict = {choicedict}

    def totuplelist(ddfile):
        return list(Choices.choicedict[ddfile].items())

""".format(date = d.strftime("%B %e, %Y"), choicedict = choicedict)

    return choicespy

def configmodels(jsonconfig):
    dbconfig = []
    table = ""
    cfgdata = {}
    for category in jsonconfig["table"].keys():
        dbconfig = jsonconfig["table"][category]
        for col in dbconfig:
            dt = col["datatype"]
            
            cfgdata[col["col"]] = col
        
            if dt in "select":
                table += f"    {col['col']} = models.CharField(blank = True, max_length = 128, choices = Choices.totuplelist(\"{col['ddfile']}\"))\n" 
                table += f"    {col['col']}.group = \"{category}\"\n"
            elif dt == "string":
                table += f"    {col['col']} = models.CharField(blank = True, max_length = {col['max']})\n"
                table += f"    {col['col']}.group = \"{category}\"\n"
            elif dt == "text":
                table += f"    {col['col']} = models.TextField(blank = True, null = True)\n"
                table += f"    {col['col']}.group = \"{category}\"\n"
            elif dt == "date":
                table += f"    {col['col']} = models.DateField(null = True)\n"
                table += f"    {col['col']}.group = \"{category}\"\n"
            else:
                print(f"WARNING: Unknown datatype \"{dt}\", skipping")
    
    groups = ""
    for i in jsonconfig["table"].keys():
        groups += """
    def group_{i}(self):
        return filter(lambda x: x.group == "{i}", self.fields.values())
""".format(i = i)
        
    colnames = []
    for x in jsonconfig["table"].keys():
        for y in jsonconfig["table"][x]:
            colnames.append(y["col"])
    
    colnames = ["inid"] + colnames
    colnames.append("tcrd")
    colnames.append("tmod")
    todict = ""
    for i in colnames:
        todict += f"\"{i}\": self.{i}, "
    todict = "{" + todict + "}"
    
    d = datetime.now(timezone.utc)
    modelspy = """# ContactList - CTCL 2023-2024
# Generated: {date}
# Purpose: Database model metadata
# THIS FILE IS AUTOMATICALLY GENERATED

from django.utils import timezone
from django.db import models
from .choices import Choices

class ContactItem(models.Model):
    # inid, tcrd, tmod are not defined by the configuration file
    inid = models.AutoField(primary_key = True)
    tcrd = models.DateTimeField(null = True)
    tmod = models.DateTimeField(null = True)

{table}
    class Meta:
        verbose_name_plural = "Contact Entries"

    def todict(self):
        return {todict}
        
    def cfgdata():
        return {cfgdata}
        
    def fieldnames():
        return {colnames}
        
    def __str__(self):
        return self.name

""".format(date = d.strftime("%B %e, %Y"), table = table, groups = groups, todict = todict, cfgdata = cfgdata, colnames = colnames)
    
    return modelspy
    
def configfields(jsonconfig):
    fielddicts = {}
    allfields = []
    allfielddicts = []
    for table in jsonconfig["table"].keys():
        fielddicts[table] = jsonconfig["table"][table]
        allfielddicts += jsonconfig["table"][table]
    hconfig = jsonconfig["headers"]
    
    for field in allfielddicts:
        allfields.append(field["col"])

    labels = {}
    for field in allfielddicts:
        dt = field["datatype"]
        col = field["col"]
        
        labels[col] = hconfig[col]

    fieldlayout = []
    for cat, catname in jsonconfig["tablecats"].items():
        fieldlayout.append("Fieldset(")
        fieldlayout.append(f"    \"{catname}\",")
        for field in fielddicts[cat]:
            fieldlayout.append(f"    \"{field['col']}\",")
        fieldlayout.append("),")

    fieldlayout = "\n".join(fieldlayout)

    d = datetime.now(timezone.utc)
    fieldspy = """# ContactList - CTCL 2023-2024
# Generated: {date}
# Purpose: Django form data
# THIS FILE IS AUTOMATICALLY GENERATED

from django import forms
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Layout, Fieldset, Submit
from .choices import Choices
from .models import ContactItem

class ContactForm(forms.ModelForm):
    class Meta:
        model = ContactItem
        fields = {allfields}
        labels = {labels}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.helper = FormHelper()
        self.helper.form_method = 'post'
        self.helper.layout = Layout(
            {fieldlayout}
            Submit('submit', 'Submit')
        )

class SearchForm(forms.Form):
    query = forms.CharField(label = "Search", max_length = 128)

""".format(date = d.strftime("%B %e, %Y"), allfields = allfields, labels = labels, fieldlayout = fieldlayout)

    return fieldspy

class Command(BaseCommand):
    help = "Generates a model.py for the application using config files under config/database/"
    
    def handle(self, *args, **options):
        # Create a backup of the database since migrations may wipe the data
        if os.path.exists("db.sqlite3"):
            if os.path.exists("db_backup.sqlite3"):
                os.remove("db_backup.sqlite3")
                
            shutil.copyfile("db.sqlite3", "db_backup.sqlite3")
        
        for path in ["node_modules/bootstrap/", "node_modules/jquery", "node_modules/tablesorter"]:
            if not os.path.exists(path):
                print(f"genmodels.py ERROR: Required Node module {path} directory missing")
                return         

        if not os.path.exists("app/static/bootstrap/"):
            os.mkdir("app/static/bootstrap/")
            shutil.copyfile("node_modules/bootstrap/dist/js/bootstrap.min.js", "app/static/bootstrap/bootstrap.min.js")
            shutil.copyfile("node_modules/bootstrap/dist/js/bootstrap.min.js", "app/static/bootstrap/bootstrap.min.js")
            # TODO: rest of this

        # Current working directory should be the project root
        try:
            with open("config/config.json") as f:
                jsonconfig = json.loads(f.read())["config"]
        except FileNotFoundError:
            cwd = os.getcwd()
            print(f"genmodels.py ERROR: config/config.json does not exist. Current working directory is \"{cwd}\".")
            return
        except (json.JSONDecodeError, json.decoder.JSONDecodeError) as e:
            print(f"genmodels.py ERROR: Exception \"{e}\" raised by JSON library")
            return

        styles = {}
        if os.path.exists(jsonconfig["misc"]["tsscss"]):
            with open(jsonconfig["misc"]["tsscss"]) as f:
                inputscss = f.read()
                try:
                    processedscss = Compiler().compile_string(inputscss)
                    processedscss = compress(processedscss)
                except Exception as err:
                    print(f"build.py ERROR: SCSS compilation exception when processing {jsonconfig['misc']['tsscss']}: {err}")
                    return

                styles["tablesorter"] = processedscss
        
        if os.path.exists(jsonconfig["misc"]["mainscss"]):
            with open(jsonconfig["misc"]["mainscss"]) as f:
                inputscss = f.read()
                try:
                    processedscss = Compiler().compile_string(inputscss)
                    processedscss = compress(processedscss)
                except Exception as err:
                    print(f"build.py ERROR: SCSS compilation exception when processing {jsonconfig['misc']['mainscss']}: {err}")
                    return

                styles["main"] = processedscss

        with open("styling.json", "w") as f:
            f.write(json.dumps(styles))
        
        with open("main/choices.py", "w") as f:
            f.write(configchoices(jsonconfig))
        
        with open("main/models.py", "w") as f:
            f.write(configmodels(jsonconfig))
            
        with open("main/fields.py", "w") as f:
            f.write(configfields(jsonconfig))