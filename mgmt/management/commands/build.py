# ContactList - CTCL 2023
# File: build.py
# Purpose: Management command for generating database models, form data and other files
# Created: June 9, 2023
# Modified: November 14, 2023

from django.core.management.base import BaseCommand, CommandError
import os, json, shutil, platform, sys
from datetime import datetime, timezone
from csscompressor import compress
from scss import Compiler
from contactlist.lib import printe

# Valid data types
# - date: datetime.date object, editable via Django DateField form class
# - select: Value chosen by a dropdown menu
# - string: Text input with a text length limit
# - text: Text input that is displayed using a textarea
# - mdtext: Text input using markdownx forms

def configthemes(basecss, gconfig):
    themecfg = {}
    for cfgtheme in gconfig["themes"]["themes"]:
        theme = cfgtheme
        if os.path.exists(cfgtheme["scss"]):
            with open(cfgtheme["scss"]) as f:
                themescss = f.read()

            try:
                theme["css"] = Compiler().compile_string(themescss)
            except Exception as err:
                printe(f"build.py configthemes ERROR: SCSS compilation error when parsing {cfgtheme['scss']}: {err}")
                theme["css"] = ""
        else:
            printe(f"build.py configthemes ERROR: Path {cfgtheme['scss']} does not exist, theme-specific styling may not be available")
            theme["css"] = ""

        themecfg[cfgtheme["int_name"]] = theme

    return themecfg

def configchoices(themecfg, gconfig, tconfig):
    choicedict = tconfig["dropdown"]

    themechoices = {}
    for k, v in themecfg.items():
        themechoices[k] = v["disp_name"]

    choicedict["themes"] = themechoices

    d = datetime.now(timezone.utc)
    choicespy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Dropdown choices
# THIS FILE IS AUTOMATICALLY GENERATED

class Choices:
    choicedict = {choicedict}

    def totuplelist(ddfile):
        return list(Choices.choicedict[ddfile].items())

""".format(date = d.strftime("%B %e, %Y"), choicedict = choicedict)

    return choicespy

def configfields(gconfig, tconfig):
    allfields = []
    for i in tconfig["table"].keys():
        allfields += tconfig["table"][i]
    hconfig = tconfig["headers"]
    fields = []
    labels = {}
    for i in allfields:
        dt = i["datatype"]
        col = i["col"]

        if dt in ["date", "select", "string", "text", "mdtext"]:
            fields.append(col)
            labels[col] = hconfig[col]
        else:
            pass

    d = datetime.now(timezone.utc)
    fieldspy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Django form data
# THIS FILE IS AUTOMATICALLY GENERATED

from django import forms
from .choices import Choices
from .models import ContactItem
from markdownx.fields import MarkdownxFormField

class ContactForm(forms.ModelForm):
    class Meta:
        model = ContactItem
        fields = {fields}
        labels = {labels}

class SettingsForm(forms.Form):
    theme = forms.CharField(label = "Theme Selection", widget = forms.Select(choices = Choices.totuplelist("themes")))

class SearchForm(forms.Form):
    query = forms.CharField(label = "Search", max_length = 128)

""".format(date = d.strftime("%B %e, %Y"), fields = fields, labels = labels)

    return fieldspy

def configmodels(gconfig, tconfig):
    dbconfig = []
    table = ""
    cfgdata = {}
    for x in tconfig["table"].keys():
        dbconfig = tconfig["table"][x]
        for y in dbconfig:
            dt = y["datatype"]

            cfgdata[y["col"]] = y

            if dt in "select":
                table += f"    {y['col']} = models.CharField(blank = True, max_length = 128, choices = Choices.totuplelist(\"{y['ddfile']}\"))\n    {y['col']}.group = \"{x}\"\n"
            elif dt == "string":
                table += f"    {y['col']} = models.CharField(blank = True, max_length = {y['max']})\n    {y['col']}.group = \"{x}\"\n"
            elif dt == "text":
                table += f"    {y['col']} = models.TextField(blank = True, null = True)\n    {y['col']}.group = \"{x}\"\n"
            elif dt == "mdtext":
                table += f"    {y['col']} = models.TextField(blank = True, null = True)\n    {y['col']}.group = \"{x}\"\n"
            elif dt == "date":
                table += f"    {y['col']} = models.DateField(null = True)\n    {y['col']}.group = \"{x}\"\n"
            else:
                print(f"WARNING: Unknown datatype \"{dt}\", skipping")

    groups = ""
    for i in tconfig["table"].keys():
        groups += """
    def group_{i}(self):
        return filter(lambda x: x.group == "{i}", self.fields.values())
""".format(i = i)

    colnames = []
    for x in tconfig["table"].keys():
        for y in tconfig["table"][x]:
            colnames.append(y["col"])

    colnames = ["inid"] + colnames + ["tmod", "tcrd"]

    todict = ""
    for i in colnames:
        todict += f"\"{i}\": self.{i}, "
    todict = "{" + todict + "}"
    d = datetime.now(timezone.utc)
    modelspy = """# ContactList - CTCL 2023
# Generated: {date}
# Purpose: Database model metadata
# THIS FILE IS AUTOMATICALLY GENERATED

from .choices import Choices
from django.utils import timezone
from django.db import models
from markdownx.models import MarkdownxField

class ContactItem(models.Model):
    # inid, tcrd, tmod are not defined by the configuration file
    inid = models.AutoField(primary_key = True)
    tcrd = models.DateTimeField(null = True)
    tmod = models.DateTimeField(null = True)

{table}
    class Meta:
        verbose_name_plural = "Contact Entries"

    def todict(self):
        return {todict}

    def cfgdata():
        return {cfgdata}

    def fieldnames():
        return {colnames}

    def __str__(self):
        return self.name
""".format(date = d.strftime("%B %e, %Y"), table = table, groups = groups, todict = todict, cfgdata = cfgdata, colnames = colnames)

    return modelspy

class Command(BaseCommand):
    help = "Generates a model.py for the application using config files under config/database/"

    def handle(self, *args, **options):
        # Load configuration
        if os.path.exists("config/config.json"):
            with open("config/config.json") as f:
                gconfig = json.loads(f.read())["config"]
        else:
            printe("build.py ERROR: Global configuration does not exist at config/config.json")
            return

        if os.path.exists(gconfig["table"]):
            with open(gconfig["table"]) as f:
                tconfig = json.loads(f.read())["table"]
        else:
            printe(f"build.py ERROR: Table configuration does not exist at {gconfig['table']}")
            return

        if os.path.exists(gconfig["misc"]["basescss"]):
            with open(gconfig["misc"]["basescss"]) as f:
                basescss = f.read()

            try:
                basecss = Compiler().compile_string(basescss)
            except Exception as err:
                printe(f"build.py ERROR: SCSS compilation error when parsing {gconfig['misc']['basescss']}: {err}")
        else:
            printe(f"build.py ERROR: Base SCSS file does not exist at {gconfig['misc']['basescss']}")
            basecss = ""

        themecfg = configthemes(basecss, gconfig)
        with open(gconfig["themes"]["themecfg_path"], "w") as f:
            json.dump(themecfg, f)

        choicescfg = configchoices(themecfg, gconfig, tconfig)
        with open("contactlist/choices.py", "w") as f:
            f.write(choicescfg)

        fieldscfg = configfields(gconfig, tconfig)
        with open("contactlist/fields.py", "w") as f:
            f.write(fieldscfg)

        modelscfg = configmodels(gconfig, tconfig)
        with open("contactlist/models.py", "w") as f:
            f.write(modelscfg)